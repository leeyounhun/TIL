# 목차
<!-- TOC -->

- [목차](#목차)
- [1. OOP](#1-oop)
  - [1.1 개요](#11-개요)
  - [1.2 장점](#12-장점)
  - [1.3 단점](#13-단점)
  - [1.4 객체지향 설계 원칙(SOLID)](#14-객체지향-설계-원칙solid)
- [2. RESTful API](#2-restful-api)
  - [2.1 개요](#21-개요)
  - [2.2 REST의 6가지 원칙](#22-rest의-6가지-원칙)
  - [2.3 RESTful한 디자인 방법](#23-restful한-디자인-방법)
  - [2.4 장점](#24-장점)
  - [2.5 단점](#25-단점)
- [3. TDD](#3-tdd)
  - [3.1 개요](#31-개요)
  - [3.2 장점](#32-장점)
  - [3.3 단점](#33-단점)
- [4. MVC](#4-mvc)
  - [4.1 개요](#41-개요)
  - [4.2 구성 요소](#42-구성-요소)
  - [4.3 구동 원리](#43-구동-원리)
- [5. Git](#5-git)
  - [5.1 개요](#51-개요)
  - [5.2 특징](#52-특징)
  - [5.3 명령어](#53-명령어)
  - [5.4 브랜치 전략](#54-브랜치-전략)
- [6. Hash Table](#6-hash-table)
  - [6.1 개요](#61-개요)
  - [6.2 Hash Function](#62-hash-function)
  - [6.3 Resolve Conflict](#63-resolve-conflict)
    - [6.3.1 Open Address 방식 (개방주소법)](#631-open-address-방식-개방주소법)
    - [6.3.2 Separate Chaining 방식 (분리 연결법)](#632-separate-chaining-방식-분리-연결법)
- [7. TCP](#7-tcp)
  - [7.1 TCP 3 Way-Handshake](#71-tcp-3-way-handshake)
  - [7.2 TCP 4 Way-Handshake](#72-tcp-4-way-handshake)
- [8. WAS와 Web Server](#8-was와-web-server)
  - [8.1 WAS](#81-was)
  - [8.2 Web Server](#82-web-server)

<!-- /TOC -->
# 1. OOP

## 1.1 개요
* Object Oriented Programming(객체 지향 프로그래밍)
* 인간 중심적 프로그래밍 패러다임
* 현실 세계의 사물들을 객체로 하여 객체에서 원하는 특징을 가져와(추상화) 프로그래밍 하는것
## 1.2 장점
* 코드의 재사용성이 높다.
* 생산성이 높아진다.
* 디버깅이 쉽고 유지보수가 용이하다.
* 요구사항을 보다 명확히 파악할 수 있다.

## 1.3 단점
* 객체간 정보 교환이 모두 메시지로 일어나 많은 오버헤드가 발생한다.
* 객체가 상태를 가지게 되고 변수를 통해 객체가 예측할 수 없는 상태를 가지게 되어 버그를 발생시킨다.

## 1.4 객체지향 설계 원칙(SOLID)
* SRP(단일 책임 원칙)
  * Single Responsibility Principle
  * 클래스는 오직 하나의 책임만을 가지며 클래스를 변경하는 이유는 단 하나의 이유여야 한다.
* OCP(개방=폐쇄 원칙)
  * Open-Closed Principle
  * 확장에는 개방적이고 변경에는 폐쇄적이여야 한다.
* LSP(리스코프 치환 원칙)
  * Liskov Substitution Principle
  * 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
* ISP(인터페이스 분리 원칙)
  * Interface Segregation Principle
  * 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
* DIP(의존 역전 원칙)
  * Dependency Inversion Principle
  * 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.

# 2. RESTful API

## 2.1 개요
  * REST란 REpresentational State Transfer의 약자로 분산 하이퍼미디어 시스템에서 운영되는 소프트웨어 아키텍처 스타일이다.
    * 웹 애플리케이션 상에 존재하는 모든 리소스에 대해 고유의 URI를 부여하고 URI가 부여된 리소스의 상태를 응답으로 전송한다.
    * REST는 다음의 구성으로 이루어져 있다
      * 자원(RESOURCE) - URI
        * 자원은 서버에 존재하는 데이터의 총칭
        * 모든 자원은 고유의 URI(URL)을 가진다.
      * 행위(Verb) - HTTP METHOD
        * 클라이언트가 HTTP Method를 이용하여 자원을 조작하는 것.
      * 표현(Representations)
        *  자원을 조작하면 서버가 그에 대한 응답(JSON, XML)을 보내는 것.
  * REST의 기본 원칙을 성실히 지킨 서비스 디자인을 RESTful 하다고 한다.

## 2.2 REST의 6가지 원칙
* Uniform Interface(일관된 인터페이스)
  * 플랫폼에 상관없이 사용할 수 있으며 리소스의 타입에 상관 없이 같은 형태의 인터페이스로 수행한다.
* Stateless(무상태성)
  * 작업을 위한 상태정보를 따로 저장하고 관리하지 않는다.
  * 각각의 요청에 대한 정보를 저장하지 않고 별개의 요청으로 처리한다.
  * 서버는 들어오는 요청만 단순히 처리하면 되며 구현이 단순해진다.
* Cacheable (캐시 가능)
  * HTTP라는 기존 웹표준을 그대로 사용하기 때문에, 웹에서 사용하는 기존 인프라를 그대로 활용이 가능하다.
  * 따라서 캐시 기능을 이용해 같은 URI에 대한 반복된 요청을 효율적으로 처리할 수 있다.
* Self-descriptiveness (자체 표현 구조)
  *  JSON, XML 등을 이용하는 메세지 구조로 해당 메세지가 무엇을, 어떤 행위를 의미하는지 직관적으로 이해할 수 있다.
* Client - Server Architecture(서버-클라이언트 구조)
  * 서버는 API 제공, 클라이언트는 유저에 대한 처리를 전담하는 구조를 가지기 때문에 서버와 클라이언트의 역할을 분명하게 구분할 수 있다.
  * 클라이언트와 서버에서 개발해야 할 내용이 명확해지고 서로간 의존성이 줄어든다.
* Layered System(계층 구조)
  * REST 서버는 다중 계층으로 구성될 수 있으며 클라이언트와 서버의 통신 사이에 보안이나 로드 밸런싱등을 위한 중간 계층을 추가할 수 있다.

## 2.3 RESTful한 디자인 방법
* 리소스와 행위를 명시적이고 직관적으로 분리한다.
  * URI는 리소스를 표현해야 하며 리소스가 가르키는 것은 명사로 표현한다.
  * 행위는 HTTP Method(GET, POST, PUT, DELETE)로 표현한다.
* Message 는 Header 와 Body 를 명확하게 분리해서 사용한다.
  * 객체에 대한 정보는 body에 담는다.
  * API 버전 정보, 응답받고자 하는 MIME 타입 등은 header 에 담는다.
* 서버와 클라이언트가 같은 방식을 사용해서 요청하도록 한다.

## 2.4 장점
* Open API 를 제공하기 쉽다
* 멀티플랫폼 지원 및 연동이 용이하다.
* 원하는 타입으로 데이터를 주고 받을 수 있다.
* 기존 웹 인프라(HTTP)를 그대로 사용할 수 있다.

## 2.5 단점
* 사용할 수 있는 메소드가 4가지(CRUD) 밖에 없다.
* 분산환경에는 부적합하다.
* HTTP 통신 모델에 대해서만 지원한다.
* 표준이 존재하지 않는다.

# 3. TDD
## 3.1 개요
* Test-Driven Development
* 매우 짧은 개발 사이클의 반복에 의존하는 소프트웨어 개발 프로세스
* 요구되는 새로운 기능에 대한 자동화된 테스트케이스를 작성하고 해당 테스트를 통과하는 가장 간단한 코드를 작성한다.
* 테스트 통과하는 코드를 작성하고 상황에 맞게 리팩토링하는 과정을 거친다.

## 3.2 장점
* 재설계 시간 단축
* 디버깅 시간 단축
* 객체 지향적인 코드 생산
* 테스트 문서의 대체 가능
* 추가 구현의 용의함

## 3.3 단점
* 생산성 저하

# 4. MVC
## 4.1 개요
* Model-View-Controller
* 애플리케이션을 세 가지 역할로 구분한 개발 방법론
* 사용자가 Controller를 조작하면 Controller는 Model을 통해 데이터를 가져오고 그 데이터를 바탕으로 View를 통해 시각적 표현을 제어하여 사용자에게 전달
* 사용자 인터페이스로부터 비즈니스 로직을 분리
  * 시작적 요소나 그 이면에서 실행되는 비즈니스 로직을 서로 영향 없이 쉽게 고칠 수 있다.
* 모델 1 방식: JSP에서 출력과 로직을 전부 처리
  * Controller 영역에 View 영역을 같이 구현하는 방식이며, 사용자의 요청을 JSP가 전부 처리
  * 요청을 받은 JSP는 JavaBean Service Class를 사용하여 웹브라우저 사용자가 요청한 작업을 처리하고 그 결과를 출력
* 모델 2 방식: JSP에서 출력만 처리
  * 웹브라우저 사용자의 요청을 서블릿이 받고 서블릿은 해당 요청으로 View로 보여줄 것인지 Model로 보낼 것인지를 판단하여 전송
  *  HTML 소스와 JAVA소스를 분리해놓았기 때문에 모델 1 방식에 비해 확장 및 유지보수가 쉽다.

## 4.2 구성 요소
* 모델(Model)
  * 데이터를 가진 객체
  * 모델의 상태에 변화가 있을 때 컨트롤러와 뷰에 이를 통지해야 한다.
  * 사용자가 편집하길 원하는 모든 데이터를 가지고 있어야만 한다.
  * 뷰나 컨트롤러에 대해서 어떠한 정보도 알지 말아야 한다.
  * 변경이 일어나면, 변경 통지에 대한 처리방법을 구현해야 한다.
* 뷰(View)
  * 컨트롤러로부터 받은 모델의 결과값으로 사용자에게 출력할 화면을 만든다.
  * 사용자와 상호작용을 위한 인터페이스를 표시하는 영역
* 컨트롤러(Controller)
  * 사용자가 접근한 URL에 따라 사용자의 요청사항을 파악한 후에 그 요청에 맞는 데이터를 Model을 의뢰하고, 데이터를 View에 반영해서 사용자에게 알려준다.
  * 모델에 명령을 보냄으로써 뷰의 상태를 변경할 수 있다.
  * 모델이나 뷰의 변경을 모니터링해야 한다.

## 4.3 구동 원리
* C/S(Client - Server)구조로 요청을 하면 그에 맞는 응답을 하는 구조를 기본으로 하고 있다.
* 웹 브라우저가 웹 서버에 웹 애플리케이션 실행을 요청한다.
* WAS(서블릿 컨테이너)는 들어온 요청을 처리할 수 있는 서블릿을 찾아서 요청을 전달한다.
* 서블릿은 모델 객체의 메서드를 호출한다.
* 데이터를 가공하여 값 객체를 생성하거나, JDBC를 사용하여 데이터베이스와의 인터랙션을 통해 값 객체를 생성한다.
* 업무 수행을 마친 결과값을 컨트롤러에게 반환한다.
* 컨트롤러는 모델로부터 받은 결과값을 View에게 전달한다.
* JSP는 전달받은 값을 참조하여 출력할 결과 화면을 만들고 컨트롤러에게 전달한다.
* 뷰로부터 받은 화면을 웹 서버에게 전달한다.
* 웹 브라우저는 웹 서버로부터 요청한 결과값을 응답받으면 그 값을 화면에 출력한다.

# 5. Git
## 5.1 개요
* 리누스 토발즈Linus Torvalds가 2005년에 만든 분산 버전 관리 시스템(Distributed Version Control Systems)
  * 버전 관리(Version Control)란 파일의 변화를 기록하는 시스템으로 소스를 관리하는 서버에 변경사항을 기록하고, 각자 서버에서 소스를 받아서 사용할 수 있는 시스템이다.
  * 분산 버전 관리 시스템이란 시스템의 저장소(repository)가 server에만 있는게 아니라 모든 client가 저장소 역할을 하는것
    * server에서 소스코드 만이 아니라 저장소자체를 받아 온다.
    * 소스코드는 물론 그동안의 변경 이력까지 모든 정보를 가져와 로컬 컴퓨터 또한 완전한 저장소가 된다
* 매우 속도가 빠르다.

## 5.2 특징
* 브랜치(Branch)
  * 독립적으로 어떤 작업을 진행하기 위한 작업
  * 각 브랜치는 다른 브랜치의 영향을 받지 않는다.
  * 만들어진 브랜치는 다른 브랜치와 병함(merge)함으로 작업한 내용을 하나의 브랜치로 모을 수 있다.
  * 효율적인 작업을 위한 여러 전략이 존재한다.
* Git은 데이터 무결성을 보장한다.
  * 모든 파일과 커밋은 체크섬 검사를 하고, 특정 히스토리를 변경하면 해당 커밋 ID와 그 이후 모든 항목의 커밋 ID가 변경된다.
* Staging Area
  * Git은 커밋 이전에 스테이징staging area 또는 인덱스index라 불리는 상태를 가진다.
  * 이 상태에서 커밋 내역을 검토하고 특정 파일만 먼저 커밋하고 일부 파일은 나중에 커밋할 수도 있다.
* Free and Open Source
* 기존 버전 관리 시스템보다 덜 직관적이고 다루기 어렵다.

## 5.3 명령어
* git init
  * 로컬 Git 저장소를 설정한다.
  * mkdir: 디렉토리 생성
  * cd: 디렉토리로 이동
  * touch: 빈 파일 생성
  * echo "[글자]" >> [파일]: 파일에 글자 추가
* git status
  * 현재 작업 중인 파일의 상태를 확인한다.
* git add
  * 파일의 변경사항을 인덱스index에 추가한다.
    * Git은 커밋하기 전, 인덱스에 먼저 커밋할 파일을 추가한다.
* git commit
  * 인덱스에 추가된 변경 사항을 이력에 추가한다.
* git log - 이력 확인
* git reset - 이전 상태로 (이력 제거)
  * 특정 커밋까지 이력을 초기화 한다
* git revert - 이전 상태로 (이력 유지)
  * 특정 커밋을 취소하는 새로운 커밋을 만든다.
* PR까지 전체적인 과정
  * 저장소를 clone → 브랜치 생성 및 이동 → 소스코드 작성 및 변경 → 변경한 내용을 git add로 스테이징 영역에 저장 → git commit으로 변경 사항을 저장 → git push로 원격 저장소에 소스코드를 올림 → Pull Request를 전송
  
## 5.4 브랜치 전략
* gitflow
  * master : 기준이 되는 브랜치, 제품을 배포하는 브랜치
  * develop : 실제로 개발을 하는 브랜치
  * feature : 단위 기능을 개발하는 브랜치, 기능 개발이 완료되면 develop 브랜치에 Merge한다.
  * release : 배포하기 전에 먼저 QA(품질검사)를 하기위한 브랜치
  * hotfix : 배포중인 제품에 버그가 생겼을때 긴급 수정하는 브랜치
  * merge할 때 반드시 -no-ff 옵션을 사용해 branch에 대한 기록이 사라지는 것을 방지한다.
* github flow
  * Git-flow가 Github에서 사용하기에는 복잡하기 때문에 나온 전략이다.
  * master 브랜치 외에 브랜치를 따로 구분하지 않는다.
  * 수시로 배포가 일어난다.
  * master 브랜치는 어떤 때든 배포가 가능하다.
  * 브랜치를 분기할때 이름을 상세하게 작성한다.
  * 원격지 브랜치로 수시로 push 한다.
  * merge 준비가 완료되었을 때는 pull request를 생성한다.
  * master로 merge가 일어나면 자동으로 배포가 되도록 한다.
* gitlab flow
  * 복잡한 Gitflow와 단순한 Github의 절충안
  * master : 기준이 되는 브랜치
  * Production: 제품을 배포하는 브랜치
  * production 브랜치는 오직 배포만을 담당한다.
  * pre-production: production 브랜치로 merge 하기  전에 테스트를 수행하는 브랜치

# 6. Hash Table
## 6.1 개요
* 해시함수를 사용하여 변환한 값을 색인(index)으로 삼아 키(key)와 데이터(value)를 저장하는 자료구조
* 내부적으로 배열을 사용하여 데이터를 저장하기 때문에 빠른 검색 속도를 갖는다.

## 6.2 Hash Function
* 임의의 길이의 값을 고정된 크기의 값으로 변환하는 함수
* 이 함수에 의해 반환된 데이터의 고유 숫자 값을 hashcode라고 한다.
* 어설픈 hash function을 통해서 key 값들을 결정한다면 동일한 값이 도출될 수가 있다. 
  *  이를 Collision 이라고 한다.
* hash function를 무조건 1:1 로 만드는 것보다 Collision 을 최소화하는 방향으로 설계한다.
  * 1:1로 만들면 array 와 다를바 없고  hash 를 hash 답게 사용하지 못하도록 한다.

## 6.3 Resolve Conflict
### 6.3.1 Open Address 방식 (개방주소법)
* 해시 충돌이 발생하면 다른 해시 버킷에 해당 자료를 삽입하는 방식
* 해시 충돌 이 발생하면 데이터를 저장할 장소를 찾아 헤맨다. 최악의 경우 비어있는 버킷을 찾지 못하고 탐색을 시작한 위치까지 되돌아 올 수 있다. 
해시 버킷을 채운 밀도가 높아질수록 최악 발생 빈도가 늘어난다.
* Linear Probing 순차적으로 탐색하며 비어있는 버킷을 찾을 때까지 계속 진행된다.
* Quadratic probing 2 차 함수를 이용해 탐색할 위치를 찾는다.
* Double hashing probing 하나의 해쉬 함수에서 충돌이 발생하면 2 차 해쉬 함수를 이용해 새로운 주소를 할당한다. 
* Separate Chaining에 비해 캐시 효율이 높다.

### 6.3.2 Separate Chaining 방식 (분리 연결법)
* 연결 리스트를 사용하는 방식
  * 각각의 버킷(bucket)들을 연결리스트(Linked List)로 만들어 충돌 이 발생하면 해당 버킷 의 list에 추가하는 방식이다. 
  * 연결 리스트의 특징을 그대로 이어받아 삭제 또는 삽입이 간단하다.
  * 작은 데이터들을 저장할 때 연결 리스트 자체의 오버헤드가 부담이 된다.
  * 버킷을 계속해서 사용하는 Open Address 방식에 비해 테이블의 확장을 늦출 수 있다.
* Tree를 사용하는 방식 (Red-Black Tree)
  * 데이터의 개수가 많다면 연결 리스트가 아닌 Tree를 사용하여 저장한다.

# 7. TCP
## 7.1 TCP 3 Way-Handshake
* 3-way Handshaking은 양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장하고, 실제로 전달이 시작하기전에 한쪽이 다른 쪽이 준비되었다는 것을 알 수 있도록 한다.
  * 클라이언트가 SYN 플래그를 보내 SYN_SENT상태가 되고 서버의 답변을 기다리게 된다.
  * 서버는 답변으로 SYN+ACK 플래그를 보내어 통신이 가능하다는 답변을 하고 SYN_RECVED 상태가 된다.
  * 통신가능 답변을 받은 클라이언트는 ACK 플래그를 보내어 자신도 통신 준비가 되었다고 알리고, ESTABLESHED 상태가 된다.
  * 클라이언트의 통신 준비완료 메시지를 받은 서버도 ESTABLESHED상태가 되며, 통신을 위한 세션이 맺어지게 된다.
* Client --- SYN M ---> Server
* Client <--- SYN N, ACK M + 1 --- Server
* Client --- ACK N + 1 ---> Server

## 7.2 TCP 4 Way-Handshake
* 연결을 종료하기 위해 사용한다.
* 클라이언트가 연결을 종료하겠다는 FIN 플래그를 전송한다.
* 서버는 클라이언트의 요청(FIN)을 받고 확인 메시지(ACK)를 전송한다.
  * 데이터를 모두 보낼 때 까지 TIME_OUT 상태가 된다.
* 데이터를 모두 보내고 통신이 종료되면 클라이언트에서 FIN 플래그를 전송한다.
* 클라이언트는 FIN 메시지를 받고 ACK 메시지를 전송한다.
* ACK 메시지를 받은 서버는 소켓 연결을 닫는다.
* 클라이언트는 아직 다 받지 못한 데이터가 있을 것을 대비해 일정 시간 세션을 남겨둔다.
* Client --- FIN ---> Server
* Client <--- ACK --- Server
* Client <--- FIN --- Server
* Client --- ACK ---> Server

# 8. WAS와 Web Server

## 8.1 WAS
* DB 조회나 여러 로직 처리를 요구하는 동적인 컨텐츠를 제공하기 위해 만들어진 어플리케이션 서버
* HTTP를 통해 서로 다른 애플리케이션이 서로 통신하는 데 사용되는 미들웨어
* 사실상 웹 컨테이너 혹은 서블릿 컨테이너와 동일하게 취급된다
* Web Server의 기능들을 구조적으로 분리하여 처리하고자 사용한다.
* 주로 DB서버와 같이 수행된다.
* 여러개의 트랜잭션을 관리할 수 있다.
* 업무를 처리하는 비즈니스 로직을 수행한다.
* Tomcat, JBoss 등

## 8.2 Web Server
* 클라이언트로부터 HTTP 요청을 받아 정적인 컨텐츠를 제공하는 프로그램
* HTTP 프로토콜을 기반으로 하여 클라이언트의 요청을 서비스한다.
* WAS가 Web Server의 기능도 할 수 있지만 서버 부하 방지와 보안, 배포 및 유지보수의 편의성을 위해 서로 분리한다.
* IIS, apache 등