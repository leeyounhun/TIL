# 목차
<!-- TOC -->

- [목차](#목차)
- [1. OOP](#1-oop)
  - [1.1 개요](#11-개요)
  - [1.2 장점](#12-장점)
  - [1.3 단점](#13-단점)
  - [1.4 객체지향 설계 원칙(SOLID)](#14-객체지향-설계-원칙solid)
- [2. RESTful API](#2-restful-api)
  - [2.1 개요](#21-개요)
  - [2.2 REST의 6가지 원칙](#22-rest의-6가지-원칙)
  - [2.3 RESTful한 디자인 방법](#23-restful한-디자인-방법)
  - [2.4 장점](#24-장점)
  - [2.5 단점](#25-단점)

<!-- /TOC -->
# 1. OOP

## 1.1 개요
* Object Oriented Programming(객체 지향 프로그래밍)
* 인간 중심적 프로그래밍 패러다임
* 현실 세계의 사물들을 객체로 하여 객체에서 원하는 특징을 가져와(추상화) 프로그래밍 하는것
## 1.2 장점
* 코드의 재사용성이 높다.
* 생산성이 높아진다.
* 디버깅이 쉽고 유지보수가 용이하다.
* 요구사항을 보다 명확히 파악할 수 있다.

## 1.3 단점
* 객체간 정보 교환이 모두 메시지로 일어나 많은 오버헤드가 발생한다.
* 객체가 상태를 가지게 되고 변수를 통해 객체가 예측할 수 없는 상태를 가지게 되어 버그를 발생시킨다.

## 1.4 객체지향 설계 원칙(SOLID)
* SRP(단일 책임 원칙)
  * Single Responsibility Principle
  * 클래스는 오직 하나의 책임만을 가지며 클래스를 변경하는 이유는 단 하나의 이유여야 한다.
* OCP(개방=폐쇄 원칙)
  * Open-Closed Principle
  * 확장에는 개방적이고 변경에는 폐쇄적이여야 한다.
* LSP(리스코프 치환 원칙)
  * Liskov Substitution Principle
  * 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
* ISP(인터페이스 분리 원칙)
  * Interface Segregation Principle
  * 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
* DIP(의존 역전 원칙)
  * Dependency Inversion Principle
  * 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.

# 2. RESTful API

## 2.1 개요
  * REST란 REpresentational State Transfer의 약자로 분산 하이퍼미디어 시스템에서 운영되는 소프트웨어 아키텍처 스타일이다.
    * 웹 애플리케이션 상에 존재하는 모든 리소스에 대해 고유의 URI를 부여하고 URI가 부여된 리소스의 상태를 응답으로 전송한다.
    * REST는 다음의 구성으로 이루어져 있다
      * 자원(RESOURCE) - URI
        * 자원은 서버에 존재하는 데이터의 총칭
        * 모든 자원은 고유의 URI(URL)을 가진다.
      * 행위(Verb) - HTTP METHOD
        * 클라이언트가 HTTP Method를 이용하여 자원을 조작하는 것.
      * 표현(Representations)
        *  자원을 조작하면 서버가 그에 대한 응답(JSON, XML)을 보내는 것.
  * REST의 기본 원칙을 성실히 지킨 서비스 디자인을 RESTful 하다고 한다.

## 2.2 REST의 6가지 원칙
* Uniform Interface(일관된 인터페이스)
  * 플랫폼에 상관없이 사용할 수 있으며 리소스의 타입에 상관 없이 같은 형태의 인터페이스로 수행한다.
* Stateless(무상태성)
  * 작업을 위한 상태정보를 따로 저장하고 관리하지 않는다.
  * 각각의 요청에 대한 정보를 저장하지 않고 별개의 요청으로 처리한다.
  * 서버는 들어오는 요청만 단순히 처리하면 되며 구현이 단순해진다.
* Cacheable (캐시 가능)
  * HTTP라는 기존 웹표준을 그대로 사용하기 때문에, 웹에서 사용하는 기존 인프라를 그대로 활용이 가능하다.
  * 따라서 캐시 기능을 이용해 같은 URI에 대한 반복된 요청을 효율적으로 처리할 수 있다.
* Self-descriptiveness (자체 표현 구조)
  *  JSON, XML 등을 이용하는 메세지 구조로 해당 메세지가 무엇을, 어떤 행위를 의미하는지 직관적으로 이해할 수 있다.
* Client - Server Architecture(서버-클라이언트 구조)
  * 서버는 API 제공, 클라이언트는 유저에 대한 처리를 전담하는 구조를 가지기 때문에 서버와 클라이언트의 역할을 분명하게 구분할 수 있다.
  * 클라이언트와 서버에서 개발해야 할 내용이 명확해지고 서로간 의존성이 줄어든다.
* Layered System(계층 구조)
  * REST 서버는 다중 계층으로 구성될 수 있으며 클라이언트와 서버의 통신 사이에 보안이나 로드 밸런싱등을 위한 중간 계층을 추가할 수 있다.

## 2.3 RESTful한 디자인 방법
* 리소스와 행위를 명시적이고 직관적으로 분리한다.
  * URI는 리소스를 표현해야 하며 리소스가 가르키는 것은 명사로 표현한다.
  * 행위는 HTTP Method(GET, POST, PUT, DELETE)로 표현한다.
* Message 는 Header 와 Body 를 명확하게 분리해서 사용한다.
  * 객체에 대한 정보는 body에 담는다.
  * API 버전 정보, 응답받고자 하는 MIME 타입 등은 header 에 담는다.
* 서버와 클라이언트가 같은 방식을 사용해서 요청하도록 한다.

## 2.4 장점
* Open API 를 제공하기 쉽다
* 멀티플랫폼 지원 및 연동이 용이하다.
* 원하는 타입으로 데이터를 주고 받을 수 있다.
* 기존 웹 인프라(HTTP)를 그대로 사용할 수 있다.

## 2.5 단점
* 사용할 수 있는 메소드가 4가지(CRUD) 밖에 없다.
* 분산환경에는 부적합하다.
* HTTP 통신 모델에 대해서만 지원한다.
* 표준이 존재하지 않는다.
